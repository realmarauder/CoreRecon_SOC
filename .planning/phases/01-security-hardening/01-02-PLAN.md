---
phase: 01-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/core/token_blacklist.py
  - app/core/rate_limit.py
  - app/core/security.py
  - app/api/v1/auth.py
  - app/main.py
  - app/schemas/user.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "Logged-out tokens are rejected on subsequent requests"
    - "Login attempts beyond 5/minute from same IP return 429"
    - "Rate limit headers appear in login responses"
    - "Token blacklist entries expire automatically with token TTL"
  artifacts:
    - path: "app/core/token_blacklist.py"
      provides: "Redis-backed token blacklist service"
      exports: ["TokenBlacklist", "token_blacklist"]
    - path: "app/core/rate_limit.py"
      provides: "SlowAPI rate limiter configuration"
      exports: ["limiter"]
    - path: "app/core/security.py"
      provides: "JWT with jti claim"
      contains: "jti"
    - path: "app/api/v1/auth.py"
      provides: "Blacklist check in get_current_user, rate limit on login"
      contains: "is_blacklisted"
  key_links:
    - from: "app/api/v1/auth.py"
      to: "app/core/token_blacklist.py"
      via: "logout calls blacklist_token"
      pattern: "blacklist_token"
    - from: "app/api/v1/auth.py"
      to: "app/core/token_blacklist.py"
      via: "get_current_user calls is_blacklisted"
      pattern: "is_blacklisted"
    - from: "app/api/v1/auth.py"
      to: "app/core/rate_limit.py"
      via: "login decorated with limiter.limit"
      pattern: "@limiter\\.limit"
    - from: "app/main.py"
      to: "app/core/token_blacklist.py"
      via: "lifespan initializes token_blacklist"
      pattern: "token_blacklist\\.init"
---

<objective>
Implement token blacklist and rate limiting (SEC-03, SEC-04).

Purpose: Enable proper logout by invalidating tokens, and protect login endpoint from brute force attacks.
Output: Redis-backed token blacklist with automatic expiration, and rate limiting on /auth/login (5 attempts/min/IP).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-hardening/01-RESEARCH.md

# Existing files to modify
@app/core/security.py
@app/api/v1/auth.py
@app/main.py
@app/schemas/user.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add slowapi dependency and create token blacklist service</name>
  <files>requirements.txt, app/core/token_blacklist.py</files>
  <action>
**In requirements.txt:**
Add `slowapi>=0.1.9` after the existing dependencies.

**Create app/core/token_blacklist.py:**

```python
"""Token blacklist service using Redis."""

import logging
from typing import Optional

import redis.asyncio as redis

logger = logging.getLogger(__name__)


class TokenBlacklist:
    """Redis-backed token blacklist for JWT revocation."""

    def __init__(self):
        self.redis: Optional[redis.Redis] = None
        self.prefix = "token_blacklist:"

    async def init(self, redis_url: str):
        """Initialize Redis connection."""
        try:
            self.redis = redis.from_url(redis_url, decode_responses=True)
            # Test connection
            await self.redis.ping()
            logger.info("Token blacklist Redis connection established")
        except Exception as e:
            logger.warning(f"Token blacklist Redis connection failed: {e}")
            self.redis = None

    async def close(self):
        """Close Redis connection."""
        if self.redis:
            await self.redis.aclose()
            logger.info("Token blacklist Redis connection closed")

    async def blacklist_token(self, jti: str, expires_in: int) -> bool:
        """
        Add token JTI to blacklist with TTL.

        Args:
            jti: JWT ID to blacklist
            expires_in: Seconds until token expires (TTL for blacklist entry)

        Returns:
            True if successfully blacklisted, False if Redis unavailable
        """
        if not self.redis:
            logger.warning("Cannot blacklist token - Redis not connected")
            return False

        try:
            await self.redis.setex(f"{self.prefix}{jti}", expires_in, "1")
            logger.debug(f"Blacklisted token {jti[:8]}... for {expires_in}s")
            return True
        except redis.RedisError as e:
            logger.error(f"Failed to blacklist token: {e}")
            return False

    async def is_blacklisted(self, jti: str) -> bool:
        """
        Check if token JTI is blacklisted.

        Args:
            jti: JWT ID to check

        Returns:
            True if blacklisted, False otherwise (including Redis errors)
        """
        if not self.redis:
            # Fail open if Redis unavailable (log warning)
            logger.warning("Cannot check blacklist - Redis not connected")
            return False

        try:
            result = await self.redis.exists(f"{self.prefix}{jti}")
            return bool(result)
        except redis.RedisError as e:
            logger.error(f"Blacklist check failed: {e}")
            return False  # Fail open with logging


# Global singleton instance
token_blacklist = TokenBlacklist()
```
  </action>
  <verify>
```bash
pip install slowapi>=0.1.9

python -c "
from app.core.token_blacklist import TokenBlacklist, token_blacklist
print('TokenBlacklist class imported successfully')
print(f'Global instance prefix: {token_blacklist.prefix}')
"
```
  </verify>
  <done>
slowapi installed. TokenBlacklist class created with init/close/blacklist_token/is_blacklisted methods. Global singleton instance available.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create rate limiter and update JWT with jti claim</name>
  <files>app/core/rate_limit.py, app/core/security.py, app/schemas/user.py</files>
  <action>
**Create app/core/rate_limit.py:**

```python
"""Rate limiting configuration using SlowAPI."""

from slowapi import Limiter
from slowapi.util import get_remote_address

from app.config import settings


def create_limiter() -> Limiter:
    """
    Create rate limiter with Redis backend for production.

    Uses in-memory storage for development, Redis for production.
    """
    # Use Redis backend in non-development environments
    storage_uri = None
    if settings.env != "development" and settings.redis_url:
        storage_uri = settings.redis_url

    return Limiter(
        key_func=get_remote_address,
        storage_uri=storage_uri,
        default_limits=["100/minute"],  # Global default
    )


# Global limiter instance
limiter = create_limiter()
```

**Update app/core/security.py:**

1. Add `import uuid` at the top
2. Add `jti: Optional[str] = None` field to TokenData class
3. Modify `create_access_token` to include jti:
   - Generate `jti = str(uuid.uuid4())`
   - Add `"jti": jti` and `"iat": datetime.utcnow().timestamp()` to `to_encode`
4. Modify `create_refresh_token` similarly to include jti
5. Modify `decode_token` to extract jti from payload:
   - Add `jti: str = payload.get("jti")` after extracting other fields
   - Return `TokenData(username=username, user_id=user_id, expires=expires, jti=jti)`

**Update app/schemas/user.py:**
Verify the Token schema exists. If not present, ensure it has:
- `access_token: str`
- `refresh_token: str`
- `token_type: str`
  </action>
  <verify>
```bash
python -c "
from app.core.rate_limit import limiter
print(f'Limiter key_func: {limiter._key_func.__name__}')

from app.core.security import create_access_token, decode_token
token = create_access_token({'sub': 'testuser', 'user_id': 1})
data = decode_token(token)
print(f'Token has jti: {data.jti is not None}')
print(f'JTI value: {data.jti[:8]}...')
"
```
  </verify>
  <done>
Rate limiter created with Redis backend for production. JWT tokens now include jti (UUID) and iat claims. TokenData includes jti field.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate blacklist and rate limiting into auth endpoints</name>
  <files>app/api/v1/auth.py, app/main.py</files>
  <action>
**Update app/api/v1/auth.py:**

1. Add imports at top:
   ```python
   from fastapi import Request
   from app.core.token_blacklist import token_blacklist
   from app.core.rate_limit import limiter
   ```

2. Modify `get_current_user` function to check blacklist:
   - After `token_data = decode_token(token)` and the None check
   - Add:
     ```python
     # Check if token is blacklisted
     if token_data.jti and await token_blacklist.is_blacklisted(token_data.jti):
         raise credentials_exception
     ```

3. Update `login` endpoint:
   - Add `request: Request` as first parameter (required for rate limiting)
   - Add `@limiter.limit("5/minute")` decorator AFTER @router.post

4. Update `logout` endpoint:
   - Add `token: Annotated[str, Depends(oauth2_scheme)]` parameter
   - Replace `pass` with:
     ```python
     token_data = decode_token(token)
     if token_data and token_data.jti and token_data.expires:
         remaining = int((token_data.expires - datetime.utcnow()).total_seconds())
         if remaining > 0:
             await token_blacklist.blacklist_token(token_data.jti, remaining)
     ```

**Update app/main.py:**

1. Add imports:
   ```python
   from slowapi import _rate_limit_exceeded_handler
   from slowapi.errors import RateLimitExceeded
   from app.core.rate_limit import limiter
   from app.core.token_blacklist import token_blacklist
   ```

2. After `app = FastAPI(...)`, add:
   ```python
   app.state.limiter = limiter
   app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
   ```

3. In `lifespan` function, after the startup validation (or connect_to_db if Plan 01 not yet applied):
   - Add: `await token_blacklist.init(settings.redis_url)`

4. In `lifespan` function, in the shutdown section (after yield), add:
   - Add: `await token_blacklist.close()` (before close_db_connection)
  </action>
  <verify>
```bash
# Verify imports work
python -c "
from app.main import app
print('App imports successful')
"

# Verify rate limiter is attached
python -c "
from app.main import app
assert hasattr(app.state, 'limiter'), 'Limiter not attached to app state'
print('Rate limiter attached to app.state')
"

# Verify login endpoint has Request parameter (check signature)
python -c "
import inspect
from app.api.v1.auth import login
sig = inspect.signature(login)
params = list(sig.parameters.keys())
assert 'request' in params, f'Request param missing. Params: {params}'
print('Login endpoint has request parameter')
"
```
  </verify>
  <done>
Token blacklist integrated: logout adds token to blacklist, get_current_user rejects blacklisted tokens. Rate limiter applied to login (5/minute). Blacklist initialized/closed in app lifespan.
  </done>
</task>

</tasks>

<verification>
1. `pip install -r requirements.txt` succeeds with slowapi
2. App starts: `python -c "from app.main import app"`
3. JWT tokens include jti claim: decode a token and verify jti field
4. Rate limit headers present in login response (X-RateLimit-Limit, etc.)
</verification>

<success_criteria>
- SEC-03: Logout blacklists token JTI in Redis with TTL matching remaining token lifetime
- SEC-03: get_current_user rejects blacklisted tokens with 401
- SEC-03: Blacklist entries auto-expire (no manual cleanup needed)
- SEC-04: Login endpoint limited to 5 requests/minute per IP
- SEC-04: 6th login attempt within a minute returns 429 Too Many Requests
- SEC-04: Rate limit headers (X-RateLimit-*) included in responses
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-hardening/01-02-SUMMARY.md`
</output>
